# Class Definitions ======

# double with units constructor
new_iso_double_with_units <- function(x = double(), units = "undefined units") {
  vctrs::vec_assert(x, ptype = double())
  vctrs::vec_assert(units, ptype = character(), size = 1)
  if (is.na(units[1])) stop("units must be set (NA is not permissible)", call. = FALSE)
  vctrs::new_vctr(x, units = units, class = "iso_double_with_units")
}

#' Generate a numeric (double) value with units
#' 
#' This function generates a number with units that work well within data frames and tibbles and implement safety checks on numerical operations with numbers that have different units. To retrieve the numerical value without units, use \code{\link{iso_strip_units}} (works for single variables and data frames/tibbles) or simply \code{as.numeric} (for single variables). To retrieve the unit use \code{\link{iso_get_units}}. Note that to correctly combine data frames / tibbles that have values with units in them, use \link[vctrs]{vec_rbind} instead of \link{rbind} or \link[dplyr]{bind_rows}. \link[vctrs]{vec_rbind} will combine columns that have values with units if they have the same unit and otherwise convert to a simple number with a warning. The other functions will either fail or reduce the unit values to plain numbers with a cryptic warning message about not preserving attributes.
#' 
#' @param x the numeric values (single value or vector)
#' @param units the units the numeric value is in, by default "undefined units" but this parameter should always be supplied when working with real data that has units
#' @family functions for values with units
#' @export
iso_double_with_units <- function(x = double(), units = "undefined units") {
  x <- vctrs::vec_cast(x, double())
  units <- vctrs::vec_recycle(vctrs::vec_cast(units, character()), 1L)
  new_iso_double_with_units(x, units = units)
}

#' @importFrom methods setOldClass
methods::setOldClass(c("iso_double_with_units", "vctrs_vctr"))

#' Check if a value has units
#' 
#' Check if a variable is a double with units. That is if it has been generated by \code{\link{iso_double_with_units}}.
#' @family functions for values with units
#' @export
iso_is_double_with_units <- function(x) {
  inherits(x, "iso_double_with_units")
}

#' Retrieve number units
#' 
#' This function returns the units of a numerical value generated by \code{\link{iso_double_with_units}}. It returns \code{NA}) for unitless variables. Returns a column-named vector of units if \code{x} is a data frame / tibble. Returns the direct units of \code{x} in all other cases.
#' @param x variable to get the units for (vector or data frame)
#' @family functions for values with units
#' @export 
iso_get_units <- function(x) {
  if (is.data.frame(x)) {
    units <- purrr::map_chr(x, iso_get_units)
  } else {
    units <- attr(x, "units")
    if (is.null(units)) units <- NA_character_
  }
  return(units)
}


#' Strip units from variables
#' 
#' This function converts numbers with units back into unitless numbers both for single variables and data frames / tibbles. For single variables, this is equivalent to the \code{as.numeric} function.
#' @param x variable to strip units from (vector or data frame)
#' @family functions for values with units
#' @export
iso_strip_units <- function(x) {
  if (is.data.frame(x)) {
    x <- dplyr::mutate_if(x, iso_is_double_with_units, as.numeric)
  } else if (iso_is_double_with_units(x)) {
    x <- as.numeric(x)
  }
  return(x)
}

#' Make units explicit
#' 
#' This function is intended for data frames / tibbles only and makes the units of columns that have numbers with units explicit in the column name. It also strips the units attribute from those columns using \code{\link{iso_strip_units}}. The reverse function is \code{\link{iso_make_units_implicit}}.
#' 
#' @param df the data frame in which to make the units explicit
#' @param prefix the prefix for the units
#' @param suffix the suffix for the units
#' @family functions for values with units
#' @example 
#' df <- tibble(peak = 1:5, height = iso_double_with_units(1:5, "V"))
#' df # shows data frame with implicit units
#' iso_make_units_explicit(df) # with explicit units
#' iso_make_units_explicit(df, prefix = ".", suffix = "") # with explicit units (custom prefix & suffix)
#' @export
iso_make_units_explicit <- function(df, prefix = " [", suffix = "]") {
  if(!is.data.frame(df)) stop("can only make units explicit in data frames", call. = FALSE)
  col_names <- names(df)
  col_units <- iso_get_units(df)
  new_col_names <- ifelse(is.na(col_units), col_names, paste0(col_names, prefix, col_units, suffix))
  df <- iso_strip_units(df)
  names(df) <- new_col_names
  return(df)
}

#' Make units implicit
#' 
#' This function is intended for data frames /tibbles only and tries to figure out which numeric columns have units in the column names and makes those units implicit using \code{\link{iso_double_with_units}}. The reverse function is \code{\link{iso_make_units_explicit}}.
#' @param df the data frame in which to make the units implicit/eplicit
#' @inheritParams iso_make_units_explicit
#' @example 
#' df <- tibble(peak = 1:5, `height [V]` = 1:5)
#' iso_make_units_implicit(df) # implicit units
#' iso_make_units_implicit(df) %>% iso_make_units_explicit() # convert back and forth
#' iso_make_units_implicit(tibble(peak = 1:5, height.V = 1:5), prefix = ".", suffix = "") # implicit units from custom prefix & suffix
#' @export
iso_make_units_implicit <- function(df, prefix = " [", suffix = "]") {
  if(!is.data.frame(df)) stop("can only make units implicit in data frames", call. = FALSE)
  if(nchar(prefix) == 0) stop("prefix must be at least 1 character", call. = FALSE)
  col_names <- names(df)
  # find pattern keeping in mind that prefix and suffix could be a random set of 
  # characters so we don't just want to stick them into a regexp and use fixed instead
  if (nchar(suffix) > 0)
    ends_with_suffix <- stringr::str_ends(col_names, fixed(suffix))
  else 
    ends_with_suffix <- rep(TRUE, length(col_names))
  col_names <- stringr::str_sub(col_names, 1L, -1L - ends_with_suffix * nchar(suffix))
  prefix <- stringr::str_locate_all(col_names, fixed(prefix))
  prefix_start <- prefix %>% purrr::map(~.x[,1]) %>% purrr::map_int(~if(length(.x) == 0) { NA_integer_ } else { max(.x) })
  prefix_end <- prefix %>% purrr::map(~.x[,2]) %>% purrr::map_int(~if(length(.x) == 0) { NA_integer_ } else { max(.x) })
  has_units <- ends_with_suffix & !is.na(prefix_end)
  
  # update units
  units <- stringr::str_sub(col_names[has_units], prefix_end[has_units] + 1L)
  df[has_units] <- map2(df[has_units], units, ~iso_double_with_units(.x, units = .y))
  
  # update column names
  col_names <- stringr::str_sub(col_names, 1L, prefix_start - 1L)
  new_col_names <- names(df)
  new_col_names[has_units] <- col_names[has_units]
  names(df) <- new_col_names
  
  return(df)
}

# check for identical units (convenience function)
check_units_identical <- function(x, y, warn_if_not = FALSE) {
  check <- identical(attr(x, "units"), attr(y, "units"))
  if (!check && warn_if_not) {
    glue::glue(
      "don't know how to reconcile different units '{iso_get_units(x)}' and ",
      "'{iso_get_units(y)}', converting to double without units to continue") %>% 
      warning(call. = FALSE, immediate. = TRUE)
  }
  return(check)
}

# formatting during printout
vec_ptype_full.iso_double_with_units <- function(x, ...) {
  sprintf("%s in '%s'", vctrs::vec_ptype_full(vctrs::vec_data(x), ...), iso_get_units(x))
}
format.iso_double_with_units <- function(x, ...) {
  format(vctrs::vec_data(x), ...)
}
vec_ptype_abbr.iso_double_with_units <- function(x, ...) {
  if (check_units_identical(x, new_iso_double_with_units())) x_units <- "undef"
  else x_units <- iso_get_units(x)
  sprintf("%s[%s]", vctrs::vec_ptype_abbr(vctrs::vec_data(x), ...), x_units)
}

# Combinations and Casting ======
#' @importFrom vctrs vec_ptype2
#' @method vec_ptype2 iso_double_with_units
#' @export
#' @export vec_ptype2.iso_double_with_units
vec_ptype2.iso_double_with_units <- function(x, y, ...) UseMethod("vec_ptype2.iso_double_with_units", y)
#' @method vec_ptype2.iso_double_with_units default
#' @export
vec_ptype2.iso_double_with_units.default <- function(x, y, ..., x_arg = "x", y_arg = "y") {
  vctrs::vec_default_ptype2(x, y, x_arg = x_arg, y_arg = y_arg)
}

#' @importFrom vctrs vec_cast
#' @method vec_cast iso_double_with_units
#' @export
#' @export vec_cast.iso_double_with_units
vec_cast.iso_double_with_units <- function(x, to, ...) UseMethod("vec_cast.iso_double_with_units")
#' @method vec_cast.iso_double_with_units default
#' @export
vec_cast.iso_double_with_units.default <- function(x, to, ...) vctrs::vec_default_cast(x, to)

# combining doubles with units: only allow it if they have the same units
#' @method vec_ptype2.iso_double_with_units iso_double_with_units
#' @export
vec_ptype2.iso_double_with_units.iso_double_with_units <- function(x, y, ...) {
  if (check_units_identical(x, y, warn_if_not = TRUE)) {
    # units are the same, keep it a double with units
    new_iso_double_with_units(units = iso_get_units(x))
  } else {
    # convert to a double without units
    double()
  }
}

#' @method vec_cast.iso_double_with_units iso_double_with_units
#' @export
vec_cast.iso_double_with_units.iso_double_with_units <- function(x, to, ...)  {
  if (check_units_identical(x, to, warn_if_not = TRUE)) {
    # has the right units so there isn't anything to do for casting
    return(x)
  } else {
    # convert to a double without units
    return(vctrs::vec_data(x))
  } 
}

# combining a double with units with a double without units yields a double without units
#' @method vec_ptype2.iso_double_with_units double
#' @export
vec_ptype2.iso_double_with_units.double <- function(x, y, ...) double()
#' @importFrom vctrs vec_ptype2.double
#' @method vec_ptype2.double iso_double_with_units
#' @export
vec_ptype2.double.iso_double_with_units <- function(x, y, ...) double()

# combining a double with units with an integer yields a double without units
#' @method vec_ptype2.iso_double_with_units integer
#' @export
vec_ptype2.iso_double_with_units.integer <- function(x, y, ...) double()
#' @importFrom vctrs vec_ptype2.integer
#' @method vec_ptype2.integer iso_double_with_units
#' @export
vec_ptype2.integer.iso_double_with_units <- function(x, y, ...) double()

# no other vec_c combinations are formally allowed for now
# since double with units + character/logical/factor should really not happen

# cast from double with units to any other format makes it behave like a double
# this allows c() to work as if it was a double (but other vec_c combinations are not allowed)
#' @importFrom vctrs vec_cast.double
#' @method vec_cast.double iso_double_with_units
#' @export
vec_cast.double.iso_double_with_units <- function(x, to, ...) vctrs::vec_data(x)
#' @importFrom vctrs vec_cast.integer
#' @method vec_cast.integer iso_double_with_units
#' @export
vec_cast.integer.iso_double_with_units <- function(x, to, ...) as.integer(vctrs::vec_data(x))
#' @importFrom vctrs vec_cast.character
#' @method vec_cast.character iso_double_with_units
#' @export
vec_cast.character.iso_double_with_units <- function(x, to, ...) as.character(vctrs::vec_data(x))
#' @importFrom vctrs vec_cast.logical
#' @method vec_cast.logical iso_double_with_units
#' @export
vec_cast.logical.iso_double_with_units <- function(x, to, ...) as.logical(vctrs::vec_data(x))
#' @importFrom vctrs vec_cast.factor
#' @method vec_cast.factor iso_double_with_units
#' @export
vec_cast.factor.iso_double_with_units <- function(x, to, ...) as.factor(vctrs::vec_data(x))

# Arithmetic =======

#' @importFrom vctrs vec_arith
#' @method vec_arith iso_double_with_units
#' @export
#' @export vec_arith.iso_double_with_units
vec_arith.iso_double_with_units <- function(op, x, y, ...) {
  UseMethod("vec_arith.iso_double_with_units", y)
}
#' @method vec_arith.iso_double_with_units default
#' @export
vec_arith.iso_double_with_units.default <- function(op, x, y, ...) {
  stop_incompatible_op(op, x, y)
}

downcast_for_unknown_op <- function(op, x, y, warn = TRUE) {
  if (warn) {
    glue::glue(
      "don't know how to calculate <{vctrs::vec_ptype_full(x)}> {op} <{vctrs::vec_ptype_full(y)}>, ",
      "converting to double without units to continue"
    ) %>% warning(call. = FALSE, immediate. = TRUE)
  }
  vctrs::vec_arith_base(op, x, y)
}

# combining two units objects (if their units are identical)
# allow + and -, and / looses the units
# all other cases convert to double with a warning
#' @method vec_arith.iso_double_with_units iso_double_with_units
#' @export
vec_arith.iso_double_with_units.iso_double_with_units <- function(op, x, y, ...) {
  if (check_units_identical(x, y, warn_if_not = TRUE)) {
    switch(
      op,
      "+" = ,
      "-" = new_iso_double_with_units(vctrs::vec_arith_base(op, x, y), units = iso_get_units(x)),
      "/" = vctrs::vec_arith_base(op, x, y),
      # downcast to double
      downcast_for_unknown_op(op, x, y)
    )
  } else {
    # downcast to double
    downcast_for_unknown_op(op, x, y, warn = FALSE)
  }
}

# combining a units object with a number
# allow division and multiplication
# all other cases convert to double with a warning
#' @method vec_arith.iso_double_with_units numeric
#' @export
vec_arith.iso_double_with_units.numeric <- function(op, x, y, ...) {
  switch(
    op,
    "/" = ,
    "*" = new_iso_double_with_units(vctrs::vec_arith_base(op, x, y), units = iso_get_units(x)),
    downcast_for_unknown_op(op, x, y)
  )
}
# combining a number with a units object
# allow multiplication, everything else convert to double with warning
#' @importFrom vctrs vec_arith.numeric
#' @method vec_arith.numeric iso_double_with_units
#' @export
vec_arith.numeric.iso_double_with_units <- function(op, x, y, ...) {
  switch(
    op,
    "*" = new_iso_double_with_units(vctrs::vec_arith_base(op, x, y), units = iso_get_units(y)),
    downcast_for_unknown_op(op, x, y)
  )
}

# missing scenarios for unary +x and -x
#' @method vec_arith.iso_double_with_units MISSING
#' @export
vec_arith.iso_double_with_units.MISSING <- function(op, x, y, ...) {
  switch(op, 
         `-` = x * -1,
         `+` = x,
         vctrs::stop_incompatible_op(op, x, y)
  )
}
